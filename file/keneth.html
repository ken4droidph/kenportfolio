<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fire Text Animation with Input</title>
<style>
body { margin:0; overflow:hidden; background:#0f0f30; font-family: Arial, sans-serif; }
canvas { display:block; }
#textInput {
    position: fixed;
    top: 20px; left: 50%;
    transform: translateX(-50%);
    font-size: 1.2rem; padding: 8px 12px;
    border-radius: 8px; border: none;
    outline: none;
    max-width: 300px;
}
</style>
</head>
<body>
<input type="text" id="textInput" maxlength="8" placeholder="Type your text (max 8)">
<canvas id="canvas"></canvas>
<script>
const canvas=document.getElementById('canvas');
const ctx=canvas.getContext('2d');
let w=canvas.width=window.innerWidth;
let h=canvas.height=window.innerHeight;

window.addEventListener('resize',()=>{
    w=canvas.width=window.innerWidth;
    h=canvas.height=window.innerHeight;
});

// ===== PARTICLES =====
class Particle {
    constructor(){ this.reset(); }
    reset(){
        this.x=Math.random()*w; this.y=Math.random()*h;
        this.size=Math.random()*3+1;
        this.vx=(Math.random()-0.5)*1.5; this.vy=(Math.random()-0.5)*1.5;
        this.color=`hsl(${Math.random()*360},70%,60%)`;
        this.active=true;
    }
    update(targets){
        if(!this.active) return false;
        let minDist=Infinity, closest=null;
        targets.forEach(l=>{
            const dx=l.x-this.x, dy=l.y-this.y;
            const d=Math.sqrt(dx*dx+dy*dy);
            if(d<minDist){ minDist=d; closest=l; }
        });
        const dx=closest.x-this.x, dy=closest.y-this.y;
        if(minDist<150){ this.x+=dx*0.03; this.y+=dy*0.03; }
        if(minDist<closest.radius){ this.active=false; return true; }
        this.x+=this.vx; this.y+=this.vy;
        if(this.x<0)this.x=w;if(this.x>w)this.x=0;
        if(this.y<0)this.y=h;if(this.y>h)this.y=0;
        return false;
    }
    draw(){ if(this.active){ ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(this.x,this.y,this.size,0,Math.PI*2); ctx.fill(); } }
}

const particleCount=300;
const particles=[];
for(let i=0;i<particleCount;i++) particles.push(new Particle());

// ===== TEXT OBJECT =====
class FireText {
    constructor(text){
        this.text=text.toUpperCase().slice(0,8);
        this.baseSize=30;
        this.size=this.baseSize;
        this.x=w/2;
        this.y=h/2;
        this.dx=1.5;
        this.dy=1.2;
        this.letters=[];
        this.exploding=false;
        this.explodeTimer=0;
        this.frameCounter=0;
    }

    update(particles){
        // Move randomly
        this.x += this.dx; this.y += this.dy;
        if(this.x<150 || this.x>w-150) this.dx*=-1;
        if(this.y<100 || this.y>h-100) this.dy*=-1;

        this.updateLetters();

        // particles
        let eatenThisFrame=0;
        particles.forEach(p=>{
            if(p.update(this.letters)) eatenThisFrame++;
        });

        // grow over 30s
        this.frameCounter++;
        const maxFrames=60*30;
        if(this.frameCounter>=maxFrames && !this.exploding){ 
            this.exploding=true; this.explodeTimer=20; 
        }

        if(!this.exploding){
            const growthRatio = this.frameCounter / maxFrames;
            this.size = this.baseSize + growthRatio*70 + eatenThisFrame*0.3;
        }

        if(this.exploding){
            this.size+=10;
            this.explodeTimer--;
            if(this.explodeTimer<=0){
                this.exploding=false;
                this.frameCounter=0;
                this.size=this.baseSize;
                particles.forEach(p=>p.reset());
            }
        }
    }

    updateLetters(){
        this.letters=[];
        let startX=this.x - (this.text.length*this.size*0.6)/2;
        for(let i=0;i<this.text.length;i++){
            this.letters.push({char:this.text[i], x:startX + i*this.size*0.6, y:this.y, radius:this.size/2});
        }
    }

    draw(ctx){
        this.letters.forEach(l=>{
            const grad=ctx.createRadialGradient(l.x,l.y,0,l.x,l.y,this.size);
            grad.addColorStop(0,"#fff");
            grad.addColorStop(0.3,"#ffec00");
            grad.addColorStop(0.6,"#ff3300");
            grad.addColorStop(1,"rgba(255,0,0,0.3)");
            ctx.fillStyle=grad;
            ctx.shadowColor="#fff"; ctx.shadowBlur=15;
            ctx.font=`bold ${this.size}px Arial`;
            ctx.textAlign="center";
            ctx.textBaseline="middle";
            ctx.fillText(l.char,l.x,l.y);
        });
    }
}

// Initialize with default text
let activeTexts=[new FireText("KENETH")];

// ===== LIGHTNING =====
class Lightning{
    constructor(){ this.active=false; this.x=w/2; this.timer=0; }
    update(){
        if(!this.active && Math.random()<0.03){
            this.active=true; this.x=Math.random()*w; this.timer=0;
        }
        if(this.active) this.timer++;
        if(this.timer>8) this.active=false;
    }
    draw(ctx,textObjs){
        if(!this.active) return;
        const startX=this.x, startY=0;
        const targetObj = textObjs[Math.floor(Math.random()*textObjs.length)];
        const endX = targetObj.x+(Math.random()*targetObj.size-targetObj.size/2);
        const endY = targetObj.y+(Math.random()*targetObj.size-targetObj.size/2);
        ctx.beginPath();
        ctx.moveTo(startX,startY);
        const segments=20;
        for(let i=1;i<segments;i++){
            const px=startX+(endX-startX)/segments*i+(Math.random()-0.5)*20;
            const py=startY+(endY-startY)/segments*i+(Math.random()-0.5)*20;
            ctx.lineTo(px,py);
        }
        ctx.lineTo(endX,endY);
        ctx.strokeStyle="rgba(255,255,255,0.9)";
        ctx.lineWidth=2;
        ctx.shadowColor="#fff"; ctx.shadowBlur=10;
        ctx.stroke();
        const dx=endX-targetObj.x, dy=endY-targetObj.y;
        const dist=Math.sqrt(dx*dx+dy*dy);
        if(dist<targetObj.size){ targetObj.size+=2; } // lightning boost
    }
}

const lightning=new Lightning();

// ===== INPUT HANDLER =====
const input=document.getElementById('textInput');
input.addEventListener('keydown',(e)=>{
    if(e.key==='Enter' && input.value.trim()!==''){
        activeTexts.push(new FireText(input.value.trim()));
        input.value='';
    }
});

// ===== ANIMATE =====
function animate(){
    ctx.clearRect(0,0,w,h);

    // Update & draw all texts
    activeTexts.forEach(t=>{ t.update(particles); t.draw(ctx); });

    // Update particles
    particles.forEach(p=>p.draw());

    // Lightning
    lightning.update();
    lightning.draw(ctx,activeTexts);

    requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
